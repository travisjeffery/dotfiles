" Section: Options {{{1
set nocompatible

" Vundle {{{2
filetype off
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()
Bundle 'git@github.com:travisjeffery/IndexedSearch.git'
Bundle 'https://github.com/mileszs/ack.vim.git'
Bundle 'https://github.com/vim-scripts/bufkill.vim.git'
Bundle 'https://github.com/duff/vim-bufonly.git'
Bundle 'git://git.wincent.com/command-t.git '
Bundle 'https://github.com/godlygeek/csapprox.git'
Bundle 'https://github.com/tpope/vim-fugitive.git'
Bundle 'https://github.com/sjl/gundo.vim.git'
Bundle 'https://github.com/travisjeffery/vim-help'
Bundle 'https://github.com/tpope/vim-ragtag.git'
Bundle 'https://github.com/tpope/vim-rails.git'
Bundle 'https://github.com/tpope/vim-repeat.git'
Bundle 'https://github.com/csexton/rvm.vim.git'
Bundle 'https://github.com/vim-scripts/SearchComplete.git'
Bundle 'https://github.com/tpope/vim-surround.git'
Bundle 'https://github.com/scrooloose/syntastic.git'
Bundle 'https://github.com/kana/vim-textobj-diff.git'
Bundle 'https://github.com/kana/vim-textobj-lastpat.git'
Bundle 'https://github.com/nelstrom/vim-textobj-rubyblock.git'
Bundle 'https://github.com/kana/vim-textobj-user.git'
Bundle 'https://github.com/kana/vim-smartword.git'
Bundle 'https://github.com/tpope/vim-unimpaired.git'
Bundle 'https://github.com/Shougo/vimfiler.git'
Bundle 'https://github.com/vim-scripts/YankRing.vim.git'
Bundle 'http://github.com/mattn/zencoding-vim/'
Bundle 'https://github.com/vim-scripts/ZoomWin.git'
Bundle 'https://github.com/gregsexton/gitv.git'
Bundle 'https://github.com/tpope/vim-commentary.git'
Bundle 'https://github.com/jgdavey/vim-blockle.git'
Bundle 'https://github.com/travisjeffery/vim-colors.git'
Bundle 'https://github.com/kana/vim-grex.git'
Bundle 'https://github.com/kana/vim-operator-user.git'
Bundle 'https://github.com/kana/vim-operator-replace.git'
Bundle 'https://github.com/tpope/vim-commentary.git'
Bundle 'https://github.com/Shougo/vimproc.git'
Bundle 'https://github.com/Shougo/unite.vim.git'
Bundle 'https://github.com/vim-ruby/vim-ruby.git'
Bundle 'https://github.com/tpope/vim-rake.git'
Bundle 'https://github.com/tpope/vim-bundler.git'
Bundle 'https://github.com/altercation/vim-colors-solarized.git'
Bundle 'https://github.com/thinca/vim-quickrun.git'
Bundle 'https://github.com/thinca/vim-poslist.git'
Bundle 'https://github.com/thinca/vim-unite-history.git'
Bundle 'https://github.com/Shougo/echodoc.git'
Bundle 'https://github.com/Shougo/neocomplcache.git'
Bundle 'https://github.com/kana/vim-altercmd.git'
"}}}2

filetype plugin indent on

augroup MyAutoCmd
    autocmd!
augroup END

filetype on
syntax on
set autowrite
set lazyredraw
set backspace=indent,eol,start
set history=1000
set nostartofline
set splitbelow
set splitright
set previewheight=10
set helpheight=12
set noequalalways
set pumheight=20
set showfulltag
set cmdwinheight=5
set showcmd
set showmode
set incsearch
set mousemodel=popup
set smartcase
set hlsearch
set nowrap
set linebreak
set winwidth=84
set winheight=5
set winminheight=5
" set winheight=999
set undodir=~/.tmp
set undofile
set undolevels=1000
set undoreload=10000
if !isdirectory($HOME . "/.tmp")
    call mkdir($HOME . "/.tmp", 'p')
endif
set backupdir=~/.tmp
set directory=~/.tmp
set backup
set shiftwidth=4
set softtabstop=4
set expandtab
set autoindent
set wildmode=list:longest
set wildmenu
set wildignore=*.o,*.obj,*~,_site,.git,.svn,*.xcodeproj,*.pyc
set virtualedit=block
set matchpairs+=<:>
if v:version >= 600
    set autoread
    set foldenable
    set foldlevelstart=1
    set foldlevel=1
    set foldmethod=marker
    set printoptions=paper:letter
    set sidescrolloff=5
    set sidescroll=1
    set mouse=nvi
endif
set nolist
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
    let &listchars = "tab:\u21e5\u00b7,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u26ad"
else
    set listchars=tab:>\ ,trail:-,extends:>,precedes:<
endif
set formatoptions-=o
" tabline{{{2
set showtabline=2
set tabline=%!MyTabLine()
function! MyTabLine()
    let s = ''
    for t in range(tabpagenr('$'))
        if t + 1 == tabpagenr()
            let s .= '%#TabLineSel#'
        else
            let s .= '%#TabLine#'
        endif
        let s .= ' '
        let s .= '%' . (t + 1) . 'T'
        let s .= t + 1 . ' '
        let n = ''
        let m = 0
        let bc = len(tabpagebuflist(t + 1))
        for b in tabpagebuflist(t + 1)
            if getbufvar( b, "&buftype" ) == 'help'
                let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
            elseif getbufvar( b, "&buftype" ) == 'quickfix'
                let n .= '[Q]'
            else
                let n .= pathshorten(bufname(b))
            endif
            if getbufvar( b, "&modified" )
                let m += 1
            endif
            if bc > 1
                let n .= ' '
            endif
            let bc -= 1
        endfor
        if m > 0
            let s.= '+ '
        endif
        if n == ''
            let s .= '[No Name]'
        else
            let s .= n
        endif
        let s .= ' '
    endfor
    let s .= '%#TabLineFill#%T'
    if tabpagenr('$') > 1
        let s .= '%=%#TabLine#%999XX'
    endif
    return s
endfunction"}}}2
" scroll "{{{2
set scroll=5
set scrolloff=0
let g:scrolloff = 15 
autocmd MyAutoCmd CursorMoved * call s:reinventing_scrolloff()
let s:last_lnum = -1
function! s:reinventing_scrolloff()
    if g:scrolloff ==# 0 || s:last_lnum > 0 && line('.') ==# s:last_lnum
        return
    endif
    let s:last_lnum = line('.')
    let winline     = winline()
    let winheight   = winheight(0)
    let middle      = winheight / 2
    let upside      = (winheight / winline) >= 2
    " If upside is true, add winlines to above the cursor.
    " If upside is false, add winlines to under the cursor.
    if upside
        let up_num = g:scrolloff - winline + 1
        let up_num = winline + up_num > middle ? middle - winline : up_num
        if up_num > 0
            execute 'normal!' up_num."\<C-y>"
        endif
    else
        let down_num = g:scrolloff - (winheight - winline)
        let down_num = winline - down_num < middle ? winline - middle : down_num
        if down_num > 0
            execute 'normal!' down_num."\<C-e>"
        endif
    endif
endfunction
"}}}2
" Automatically mkdir when writing file in non-existant directory{{{2
augroup vimrc-auto-mkdir
    autocmd!
    autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
    function! s:auto_mkdir(dir, force)
        if !isdirectory(a:dir)
        \   && (a:force
        \       || input("'" . a:dir . "' does not exist. Create? [y/N]") =~? '^y\%[es]$')
            call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
        endif
    endfunction
augroup END"}}}2
set mouse=a
set ttymouse=xterm2
set t_Co=256
set hidden
set textwidth=79
set ignorecase
set dictionary-=/usr/share/dict/words dictionary+=/usr/share/dict/words
set complete-=k
set complete-=i
set fileformats=unix,dos,mac
set cursorline
set number
set timeoutlen=1000
set ttimeoutlen=50
set laststatus=2
set diffopt=filler
set diffopt+=iwhite
set switchbuf=useopen
set shell=/bin/sh
set noswapfile
set updatecount=0
if has('unix')
    set nofsync
    set swapsync=
endif
set guioptions-=T
set guioptions-=L
set guioptions-=r
set guioptions+=c
set noantialias
if has('balloon_eval')
    autocmd FileType ruby,eruby set noballooneval
    set noballooneval
endif
set norestorescreen
set t_ti=
set t_te=
set shortmess=aI
if has("mac")
    set clipboard=unnamed
    let g:gist_clip_command = 'pbcopy'
else
    let g:gist_clip_command = 'xclip -selection clipboard'
endif
if has("gui") && has("mac")
    set fuopt+=maxhorz
    set macmeta
    set antialias | set guifont=Inconsolata:h14
  else
    set guifont=Inconsolata\ 12
endif
if &term =~ "^screen"
    augroup MyAutoCmd
        autocmd VimLeave * :set mouse=
     augroup END

    " workaround for freeze when using mouse on GNU screen.
    set ttymouse=xterm2
endif
set statusline=%f
set statusline+=%{exists('g:loaded_fugitive')?fugitive#statusline():''}
set statusline+=%{exists('g:loaded_rvm')?rvm#statusline():''}
set statusline+=%#warningmsg#
set statusline+=%{&ff!='unix'?'['.&ff.']':''}
set statusline+=%*
set statusline+=%#warningmsg#
set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}
set statusline+=%*
set statusline+=%h
set statusline+=%y
set statusline+=%r
set statusline+=%m
set statusline+=%#error#
set statusline+=%*
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*
set statusline+=%=
set statusline+=%c,
set statusline+=%l/%L
set statusline+=\ %{GetDocumentPosition()}
function! GetDocumentPosition()
    return float2nr(str2float(line('.')) / str2float(line('$')) * 100) . "%"
endfunction

autocmd MyAutoCmd FileType * setl formatoptions-=ro | setl formatoptions+=mM
autocmd MyAutoCmd BufWritePost vimrc source $MYVIMRC
autocmd MyAutoCmd BufWritePost .vimrc source $MYVIMRC

" Close help and git window by pressing q.
autocmd FileType help,git-status,git-log,qf,gitcommit,quickrun,qfreplace,ref,simpletap-summary,vcs-commit,vcs-status
            \ nnoremap <buffer><silent> q :<C-u>call <sid>smart_close()<CR>
autocmd FileType * if (&readonly || !&modifiable) && !hasmapto('q', 'n')
            \ | nnoremap <buffer><silent> q :<C-u>call <sid>smart_close()<CR>| endif
function! s:smart_close()
  if winnr('$') != 1
    close
  endif
endfunction
augroup MyAutoCmd
  autocmd FileType vim nnoremap <silent><buffer> [Space]so :write \| source % \| echo "source " . bufname('%')<CR>
augroup END
" Make a scratch buffer when unnamed buffer{{{2
augroup vimrc-scratch-buffer
  autocmd!
  autocmd BufEnter * call s:scratch_buffer()
  autocmd FileType qfreplace autocmd! vimrc-scratch * <buffer>

  function! s:scratch_buffer()
    if exists('b:scratch_buffer') || bufname('%') != '' || &l:buftype != ''
      return
    endif
    let b:scratch_buffer = 1
    setlocal buftype=nofile nobuflisted noswapfile bufhidden=hide
    augroup vimrc-scratch
      autocmd! * <buffer>
      autocmd BufWriteCmd <buffer> call s:scratch_on_BufWriteCmd()
    augroup END
  endfunction
  function! s:scratch_on_BufWriteCmd()
    silent! setl buftype< buflisted< swapfile< bufhidden< nomodified
    autocmd! vimrc-scratch * <buffer>
    unlet! b:scratch_buffer
    execute 'saveas' . (v:cmdbang ? '!' : '') ' <afile>'
    filetype detect
  endfunction
augroup END"}}}2
"}}}1
" Section: Plugins {{{1
" Solarized{{{2
let g:solarized_termtrans=0
let g:solarized_degrade=0
let g:solarized_bold=1
let g:solarized_underline=1
let g:solarized_italic=1
let g:solarized_diffmode="normal"
let g:solarized_hitrail=0
let g:solarized_termcolors = 256 
let g:solarized_visibility = "high" 
let g:solarized_contrast = "high" 
set background=light
colorscheme solarized
"}}}2
" netrw {{{2
let g:netrw_list_hide= '*.swp'
nnoremap <silent> <BS> :<C-u>Explore<CR>
" Change default directory.
set browsedir=current
if executable('wget')
  let g:netrw_http_cmd = 'wget'
endif
let g:netrw_list_hide = '^\.,^tags$'
"}}}2
" rails {{{2
let g:rails_menu=0
let g:rails_installed_menu=0
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_rails = 1
"}}}2
" Syntastic {{{2
let g:syntastic_enable_signs=1
let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1
"}}}2
" QuickRun {{{2
let g:quickrun_config = {}
let g:quickrun_config['ruby'] = {'command': 'testdrb', 'exec': '%c -Itest %s'}
" let g:quickrun_config['*'] = {
"       \ 'runner/vimproc/updatetime' : 100,
"       \ 'split': 'vertical rightbelow',
"       \ 'targets' : ['quickfix', 'buffer'],
"       \ 'outputter' : 'buffer',
"       \ 'runner' : 'vimproc',
"       \ 'into' : 0,
"       \ 'runmode' : 'async:remote:vimproc'
"       \}
"}}}2
"Fugitive {{{2
nnoremap [Space]gd :<C-u>Gdiff<CR>
nnoremap [Space]gs :<C-u>Gstatus<CR>
nnoremap [Space]gl :<C-u>Glog<CR>
nnoremap [Space]gc :<C-u>Gcommit<CR>
nnoremap [Space]gC :<C-u>Git commit -- amend<CR>
nnoremap [Space]gb :<C-u>Gblame<CR>
nnoremap [Space]gr :<C-u>Gread<CR>
nnoremap [Space]gw :<C-u>Gwrite<CR>
"}}}2
let g:snips_author = "Travis Jeffery"
let g:quickrun_direction = 'rightbelow vertical'
let g:user_zen_leader_key = '<c-e>'
let g:use_zen_complete_tag = 1
let g:ragtag_global_maps = 1
let g:user_zen_settings = {
            \  'indentation' : '  ',
            \   'markdown' : { 'extends' : 'html' }
            \}
" Unite {{{2
let g:unite_enable_split_vertically = 1
let g:unite_kind_file_cd_command = 'TabpageCD'
let g:unite_kind_file_lcd_command = 'TabpageCD'
let g:unite_winheight = 20
let g:unite_enable_start_insert = 1
let g:unite_cursor_line_highlight = 'TabLineSel'
let g:unite_abbr_highlight = 'TabLine'
let g:unite_source_file_mru_time_format = ''
let g:unite_source_file_mru_filename_format = ':~:.'
let g:unite_source_file_mru_limit = 300
let g:unite_source_directory_mru_time_format = ''
let g:unite_source_directory_mru_limit = 300
nnoremap <C-B> :<C-u>Unite buffer<CR>
nnoremap <silent> [Space]:  :<C-u>Unite history/command command<CR>
"}}}2
" echodoc {{{2
let g:echodoc_enable_at_startup = 1
"}}}2
" delimitmate {{{2
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1
let delimitMate_balance_matchpairs = 1
let delimitMate_smart_quotes = 0
let delimitMate_smart_matchpairs = 0
let delimitMate_autoclose = 0
"}}}2
" YankRing {{{2
let g:yankring_max_history = 1000
let g:yankring_max_display = 100
let g:yankring_persist = 1
let g:yankring_share_between_instances = 1
let g:yankring_window_use_separate = 1
let g:yankring_window_use_horiz = 1
let g:yankring_window_auto_close = 1
let g:yankring_window_width = 30
let g:yankring_window_use_right = 1
let g:yankring_window_increment = 15
let g:yankring_history_dir = '$HOME/.tmp'
"}}}2
" surround {{{2
let g:surround_{char2nr('-')} = "<% \r %>"
let g:surround_{char2nr('=')} = "<%= \r %>"
let g:surround_{char2nr('8')} = "/* \r */"
let g:surround_{char2nr('s')} = " \r"
let g:surround_{char2nr('^')} = "/^\r$/"
let g:surround_indent = 1
"}}}2
" vimfiler {{{2
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_enable_clipboard = 0
let g:vimshell_cd_command = 'TabpageCD'
command! -nargs=0 VF :VimFiler
nnoremap <silent>   [Space]v   :<C-u>VimFiler<CR>
nmap    [Space]h   :<C-u>edit %:h<CR>
"}}}2
" SuperTab {{{2
let g:SuperTabLongestEnhanced = 1
let g:SuperTabDefaultCompletionType = "context"
"}}}2
" CommandT {{{2
let g:CommandTMatchWindowReverse  = 1
let g:CommandTMaxHeight           = 10
let g:CommandTMaxFiles            = 30000
let g:CommandTScanDotDirectories  = 1
"}}}2
" neocomplcache{{{2
let g:neocomplcache_enable_at_startup = 1
let g:neocomplcache_enable_smart_case = 1
let g:neocomplcache_enable_camel_case_completion = 1
let g:neocomplcache_enable_underbar_completion = 1
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_manual_completion_start_length = 0
let g:neocomplcache_min_keyword_length = 3
let g:neocomplcache_enable_auto_select = 1
let g:neocomplcache_enable_auto_delimiter = 1
let g:neocomplcache_disable_auto_select_buffer_name_pattern = '\[Command Line\]'
let g:neocomplcache_max_list = 100
let g:neocomplcache_force_overwrite_completefunc = 1
let g:neocomplcache_enable_cursor_hold_i = v:version > 703 ||
      \ v:version == 703 && has('patch289')
let g:neocomplcache_dictionary_filetype_lists = {
      \ 'default' : '',
      \ 'ruby' : expand('$DOTVIM/dict/ruby.dict'),
      \ }
let g:neocomplcache_omni_functions = {
      \ 'python' : 'pythoncomplete#Complete',
      \ 'ruby' : 'rubycomplete#Complete',
      \ }
let g:neocomplcache_cursor_hold_i_time = 300
if !exists('g:neocomplcache_keyword_patterns')
  let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
let g:neocomplcache_snippets_dir = $HOME . '/snippets'
if !exists('g:neocomplcache_omni_patterns')
  let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.php = '[^. *\t]\.\w*\|\h\w*::'
if !exists('g:neocomplcache_same_filetype_lists')
  let g:neocomplcache_same_filetype_lists = {}
endif
let g:neocomplcache_source_look_dictionary_path = ''
let g:neocomplcache_vim_completefuncs = {
      \ 'Ref' : 'ref#complete',
      \ 'Unite' : 'unite#complete_source',
      \ 'VimFiler' : 'vimfiler#complete',
      \}
if !exists('g:neocomplcache_plugin_completion_length')
  let g:neocomplcache_plugin_completion_length = {
        \ 'look' : 4,
        \ }
endif
"}}}2
let g:HammerQuiet = 1
let g:CSApprox_verbose_level = 0
if filereadable("/usr/local/bin/ctags")
    let g:tagbar_ctags_bin="/usr/local/bin/ctags"
else
    let g:tagbar_ctags_bin="/usr/bin/ctags"
endif
if filereadable($HOME . "/.githubrc")
    source $HOME/.githubrc
endif
if filereadable($HOME . "/.passwords")
    source $HOME/.passwords
endif
"}}}1
" Section: Commands {{{1
call altercmd#load()
command! -nargs=* -bang W :w<bang> <args>
command! -nargs=0 E :Explore
command! -nargs=0 DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
command! -bar -nargs=0 SudoW   :setl nomod|silent exe 'write !sudo tee % >/dev/null'|let &mod = v:shell_error
" CD - alternative :cd with more user-friendly completion  "{{{2

command! -complete=customlist,s:complete_cdpath -nargs=+ CD  TabpageCD <args>
function! s:complete_cdpath(arglead, cmdline, cursorpos)
  return split(globpath(&cdpath,
  \                     join(split(a:cmdline, '\s')[1:], ' ') . '*/'),
  \            "\n")
endfunction

AlterCommand cd  CD

" TabpageCD - wrapper of :cd to keep cwd for each tabpage  "{{{2

command! -nargs=? TabpageCD
\   execute 'cd' fnameescape(<q-args>)
\ | let t:cwd = getcwd()
"}}}1
" Section: Autocommands {{{1
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
autocmd FileType vim set omnifunc=syntaxcomplete#Complete
autocmd FileType css set omnifunc=csscomplete#CompleteCSS
autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType c set omnifunc=ccomplete#Complete
autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
autocmd BufNewFile,BufRead *.coffee set ft=coffee sw=2 sts=2
autocmd BufNewFile,BufRead *.css set ft=css sw=2 sts=2
autocmd BufNewFile,BufRead *.json set ft=javascript sw=2 sts=2
autocmd BufNewFile,BufRead *.rb set ft=ruby sw=2 sts=2
autocmd filetype svn,*commit*,markdown set spell
autocmd FileType cucumber compiler cucumber | setl makeprg=cucumber\ \"%:p\"
autocmd FileType ruby
            \ if expand('%') =~# '_test\.rb$' |
            \   compiler rubyunit | setl makeprg=ruby\ -Itest\ \"%:p\" |
            \ elseif expand('%') =~# '_spec\.rb$' |
            \   compiler rspec | setl makeprg=rspec\ \"%:p\" |
            \ else |
            \   compiler rubyunit | setl makeprg=ruby\ -Itest\ \"%:p\" |
            \ endif
autocmd User Bundler
            \ if &makeprg !~ 'bundle' | setl makeprg^=bundle\ exec\  | endif

autocmd BufReadPost fugitive://* set bufhidden=delete
let g:do_filetype = 0
au GUIEnter,BufAdd * if expand('<afile>') == "" | let g:do_filetype = 1 | endif
au BufEnter * if g:do_filetype | setf markdown | let g:do_filetype = 0 | endif
au BufNewFile,BufRead,BufWinEnter * if search("diff --git", 'cp', 1) | set filetype=git | endif

command! OpenChangedFiles :call OpenChangedFiles()
function! OpenChangedFiles()
    only
    let status = system('git status -s | grep "^ \?\(M\|A\)" | cut -d " " -f 3')
    let filenames = split(status, "\n")
    exec "edit " . filenames[0]
    for filename in filenames[1:]
        exec "sp " . filename
    endfor
endfunction

autocmd BufReadPost * call SetCursorPosition()
function! SetCursorPosition()
    if &filetype !~ 'svn\|commit\c'
        if line("'\"") > 0 && line("'\"") <= line("$")
            exe "normal! g`\""
            normal! zz
        endif
    end
endfunction

function! InlineVariable()
    normal "ayiw
    normal 4diw
    normal "bd$
    normal dd
    normal k$
    exec '/\<' . @a . '\>'
    exec ':.s/\<' . @a . '\>/' . @b
endfunction

command! -nargs=0 JSBeautify call JSBeautify()<CR>
function! JSBeautify()
    silent! exe "%! jsbeautifier --stdin"
endfunction
"}}}1
" Section: Abbreviations{{{1
cabbrev E e
cabbrev git Git
cabbrev ~? ~/
iabbrev Utitlies Utilities
iabbrev utitlies utilities
iabbrev init; initialize
iabbrev innit init
iabbrev innitialize initialize
iabbrev seperate separate
iabbrev teh the
iabbrev ;; =>
iabbrev shuold should
iabbrev shulod should
"}}}1
" Section: Mappings {{{1
let g:mapleader=","
nmap  <Space>   [Space]
xmap  <Space>   [Space]
nnoremap  [Space]   <Nop>
xnoremap  [Space]   <Nop>

nnoremap ; <Nop>
xnoremap ;  <Nop>
nnoremap : <Nop>
xnoremap :  <Nop>

nnoremap <SID>(command-line-enter) :
xnoremap <SID>(command-line-enter) :
nmap ; <SID>(command-line-enter)
xmap ; <SID>(command-line-enter)

nnoremap <silent> [Space]mk  :<C-u>marks<CR>
nnoremap <silent> [Space]re  :<C-u>registers<CR>
nnoremap <silent> [Space]yr  :<C-u>YRShow<CR>
nnoremap <silent> [Space]ya  :<C-u>1,$y<CR>\|:<C-u>1,$y+<CR>
nnoremap <silent> [Space]y%  :<C-u>1,$y<CR>\|:<C-u>1,$y+<CR>

" Copy current buffer's path to clipboard{{{2
nnoremap <Leader>% :<C-u>call <SID>copy_path()<CR>
function! s:copy_path()
    let @*=expand('%')
    let @"=expand('%')
    let @+=expand('%')
endfunction"}}}2

" To keep legacy surround mapping{{{2
vnoremap s S
xnoremap s S"{{{2

" Useful save mappings{{{2
nnoremap <silent> [Space]w  :<C-u>update<CR>
nnoremap <silent> [Space]fw  :<C-u>write!<CR>
nnoremap <silent> [Space]q  :<C-u>quit<CR>
nnoremap <silent> [Space]aq  :<C-u>quitall<CR>
nnoremap <silent> [Space]fq  :<C-u>quitall!<CR>
nnoremap <Leader><Leader> :<C-u>update<CR>
"}}}2

" Change current directory{{{2
nnoremap <silent> [Space]cd :<C-u>call <SID>cd_buffer_dir()<CR>
function! s:cd_buffer_dir()"{{{
  let l:filetype = getbufvar(bufnr('%'), '&filetype')
  if l:filetype ==# 'vimfiler'
    let l:dir = getbufvar(bufnr('%'), 'vimfiler').current_dir
  elseif l:filetype ==# 'vimshell'
    let l:dir = getbufvar(bufnr('%'), 'vimshell').save_dir
  else
    let l:dir = isdirectory(bufname('%')) ? bufname('%') : fnamemodify(bufname('%'), ':p:h')
  endif

  TabpageCD `=l:dir`
endfunction"}}}2
nnoremap <ESC><ESC> :nohlsearch<CR>

" Fast search pair.
nnoremap [Space]p    %
xnoremap [Space]p    %

" Fast screen move.
nnoremap [Space]j    z<CR><C-f>z.
xnoremap [Space]j    z<CR><C-f>z.
nnoremap [Space]k    z-<C-b>z.
xnoremap [Space]k    z-<C-b>z.

nnoremap [Space]ev     :<C-u>edit $MYVIMRC<CR>
nnoremap [Space]sv     :<C-u>source $MYVIMRC<CR>

" Tags {{{2
nnoremap [Space]tt <C-]>
nnoremap [Space]tn :<C-u>tnext<CR>
nnoremap [Space]tp :<C-u>tprevious<CR>
nnoremap [Space]tl :<C-u>tags<CR>
nnoremap [Space]tP :<C-u>tfirst<CR>
nnoremap [Space]tN :<C-u>tlast<CR>
nnoremap [Space]tk :<C-u>tpop<CR>
nnoremap [Space]tsn :<C-u>split<CR>\|:<C-u>tnext<CR>
nnoremap [Space]tsp :<C-u>split<CR>\|:<C-u>tprevious<CR>
nnoremap [Space]tsP :<C-u>split<CR>\|:<C-u>tfirst<CR>
nnoremap [Space]tsN :<C-u>split<CR>\|:<C-u>tlast<CR>
"}}}2

if &diff
    nmap <c-h> :diffget 1<CR>
    nmap <c-l> :diffget 3<CR>
    nmap <c-k> [cz.
    nmap <c-j> ]cz.
    set number
endif
" Move search word and fold open"{{{2
nnoremap N  Nzv
nnoremap n  nzv
nnoremap #  #zv
nnoremap g*  g*zv
nnoremap g#  g#zv
"}}}2
" smartword.vim"{{{2
" Replace w and others with smartword-mappings
nmap w  <Plug>(smartword-w)
nmap b  <Plug>(smartword-b)
nmap e  <Plug>(smartword-e)
nmap ge  <Plug>(smartword-ge)
xmap w  <Plug>(smartword-w)
xmap b  <Plug>(smartword-b)
" Operator pending mode.
omap <Leader>w  <Plug>(smartword-w)
omap <Leader>b  <Plug>(smartword-b)
omap <Leader>ge  <Plug>(smartword-ge)
"}}}2
" Command line buffer {{{2
nnoremap <sid>(command-buffer-enter) q:
xnoremap <sid>(command-buffer-enter) q:
nnoremap <sid>(command-buffer-norange) q:<C-u>
nmap :  <sid>(command-buffer-enter)
xmap :  <sid>(command-buffer-enter)
" nmap ;  <sid>(command-buffer-enter)
" xmap ;  <sid>(command-buffer-enter)
autocmd MyAutoCmd CmdwinEnter * call s:init_cmdwin()
function! s:init_cmdwin()
  nnoremap <buffer><silent> q :<C-u>quit<CR>
  inoremap <buffer><expr><TAB>  pumvisible() ? "\<C-n>" : <SID>check_back_space() ? "\<TAB>" : "\<C-x>\<C-u>\<C-p>"
  startinsert!
endfunction
function! s:check_back_space()"{{{
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~ '\s'
endfunction"}}}
"}}}2
" camlcasemotion.vim"{{{2
nmap <silent> W <Plug>CamelCaseMotion_w
xmap <silent> W <Plug>CamelCaseMotion_w
nmap <silent> B <Plug>CamelCaseMotion_b
xmap <silent> W <Plug>CamelCaseMotion_b
"}}}2
nnoremap Q gq
nnoremap <Leader>m :TagbarToggle<CR>
nnoremap <Leader>d :TagbarOpenAutoClose<CR>
nnoremap <Leader>z :ZoomWin<CR>
nnoremap <Leader>= gg=G<C-o><C-o>
nnoremap <Leader>v :<C-u>vsplit<CR><C-w><C-w>
nnoremap <Leader>s :<C-u>split<CR><C-w><C-w>
nnoremap <Leader>\ :<C-u>%! fmt -w 79<CR>
nnoremap <Leader>\ :<C-u>!fmt -w 79<CR>
nnoremap <Leader>` :<C-u>%s/\s*$//ge<CR>
nnoremap <Leader>cd :<C-u>cd %:p:h<CR>
nnoremap <silent> <Leader>y :YRShow<CR>
nnoremap <silent> <Leader>Y :GundoToggle<CR>
imap <M-o>       <Esc>o
imap <C-j>       <Down>
nmap <Leader>' ""yls<c-r>={'"': "'", "'": '"'}[@"]<CR><esc>
vmap <silent> g/ y/<C-R>=substitute(escape(@", '\\/.*$^~[]'), '\n', '\\n', 'g')<CR><CR>
nnoremap VV 0v$h
nnoremap <Leader>X <c-w><c-h>:set winwidth=80<CR><c-w><c-l>:set winwidth=31<CR><c-w><c-h>
nnoremap gff <C-w>gf
imap (( ()
inoremap <C-Space> <Right>
nmap <Leader>- i<space><esc>vs-2lxi
nmap <Leader>+ :<C-u>cd %:p:h<bar>new<Space>
imap <C-e> <esc>$a
imap <C-a> <esc>0i
imap <C-b> <esc>ha
imap <C-f> <esc>la
imap <C-d> <right><bs>
imap <silent> <C-BS> <esc>bvec
cmap <C-BS> <c-w>
nmap [2 :diffget //2<CR>
nmap ]3 :diffget //3<CR>
vmap <Leader>rv :call ExtractVariable()<CR>
nmap <Leader>ri :call InlineVariable()<CR>
nmap <Leader>/# /^ *#<CR>
nmap <Leader>/f /^ *def\><CR>
nmap <Leader>/c /^ *class\><CR>
nmap <Leader>/i /^ *if\><CR>
nmap <Leader>df d/\(^ *def\>\)\\|\%$<CR>
nmap <Leader>a= :Tabularize /=<CR>
vmap <Leader>a= :Tabularize /=<CR>
nmap <Leader>a: :Tabularize /:\zs<CR>
vmap <Leader>a: :Tabularize /:\zs<CR>
nmap <Leader>a :Tabularize /
vmap <Leader>a :Tabularize /
nmap <Leader>= G=gg<c-o><c-o>
nmap <Leader>h :help <c-r>=expand("<cword>")<CR><CR>
vmap <Leader>h "ry:help<space><c-r>r<CR>
nmap <C-cr> <esc>yyp
imap <S-cr> <esc>$o
nnoremap <C-S-cr> d$O<esc>p0x
" Split movement{{{2
nnoremap <C-h> <C-w><C-h>
nnoremap <C-j> <C-w><C-j>
nnoremap <C-k> <C-w><C-k>
nnoremap <C-l> <C-w><C-l>
"}}}2
inoremap <C-]> <Space>=><Space>
cnoremap %% <C-R>=expand('%:h').'/'<CR>
cnoremap %& <C-R>=expand('%:p')<CR>
nnoremap gV `[v`]
nmap \v /\v
nmap <S-right> g,
nmap <S-left> g;
nmap <left>  <Plug>(jump-x2-to-previous)
nmap <right>  <Plug>(jump-x2-to-next)

xmap <C-\>  <Plug>Commentary
nmap <C-\> <Plug>CommentaryLine

if hasmapto('s', 'v')
    vunmap s
endif
vmap s S
xmap s S

" nnoremap <silent> <Tab> :call <SID>NextWindow()<CR>
" nnoremap <silent> <S-Tab> :call <SID>PreviousWindowOrTab()<CR>

function! s:NextWindow()
  if winnr('$') == 1
    call s:split_nicely()
  else
    wincmd w
  endif
endfunction

function! s:NextWindowOrTab()
  if tabpagenr('$') == 1 && winnr('$') == 1
    call s:split_nicely()
  elseif winnr() < winnr("$")
    wincmd w
  else
    tabnext
    1wincmd w
  endif
endfunction

function! s:PreviousWindowOrTab()
  if winnr() > 1
    wincmd W
  else
    tabprevious
    execute winnr("$") . "wincmd w"
  endif
endfunction

" Split nicely"{{{2
command! SplitNicely call s:split_nicely()
function! s:split_nicely()
  " Split nicely.
  if winwidth(0) > 2 * &winwidth
    vsplit
  else
    split
  endif
  wincmd p
endfunction
"}}}2
" Smart }"{{{2
nnoremap <silent> } :<C-u>call ForwardParagraph()<CR>
onoremap <silent> } :<C-u>call ForwardParagraph()<CR>
xnoremap <silent> } <Esc>:<C-u>call ForwardParagraph()<CR>mzgv`z
function! ForwardParagraph()
  let cnt = v:count ? v:count : 1
  let i = 0
  while i < cnt
    if !search('^\s*\n.*\S','W')
      normal! G$
      return
    endif
    let i = i + 1
  endwhile
endfunction
"}}}
nnoremap <silent> [Space]<Space> :<C-u>buffer #<CR>
nnoremap <silent> 0 ^
nnoremap <silent> ^ 0
xnoremap <silent> 0 ^
xnoremap <silent> ^ 0
vnoremap <silent> 0 ^
vnoremap <silent> ^ 0

xmap p <Plug>(operator-replace)
xmap P <Plug>(operator-replace)

" Move to top/center/bottom.
noremap <expr> zz (winline() == (winheight(0)+1)/ 2) ? 'zt' : (winline() == 1)? 'zb' : 'zz'

" Auto escape / substitute.
xnoremap [Space]s y:%s/<C-r>=substitute(@0, '/', '\\/', 'g')<Return>//g<Left><Left>

nnoremap <Left> <Plug>(poslist-prev-buf)
nnoremap <Right> <Plug>(poslist-next-buf)

nnoremap <Leader>rf <Plug>(testee-test-file)
nnoremap <Leader>rt <Plug>(testee-test-case)
nnoremap <Leader>rl <Plug>(testee-test-last)

function! YRRunAfterMaps()
    nnoremap Y   :<C-U>YRYankCount 'y$'<CR>
    nnoremap . .`[
endfunction

function! s:VSetSearch()
    let temp = @@
    norm! gvy
    let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
    let @@ = temp
endfunction
vmap * :<C-u>call <SID>VSetSearch()<CR>//<CR>
vmap # :<C-u>call <SID>VSetSearch()<CR>??<CR>

nmap <Leader>gr :topleft :split config/routes.rb<CR>
function! ShowRoutes()
    topleft 100 :split __Routes__
    set buftype=nofile
    normal 1GdG
    0r! rake -s routes
    exec ":normal " . line("$") . "_ "
    normal 1GG
    normal dd
endfunction
nnoremap <Leader>gR :call ShowRoutes()<CR>

nnoremap <silent> <Leader>gv :<C-u>CommandTFlush<CR>\|:<C-u>CommandT app/views<CR>
nnoremap <silent> <Leader>gc :<C-u>CommandTFlush<CR>\|:<C-u>CommandT app/controllers<CR>
nnoremap <silent> <Leader>gu :<C-u>CommandTFlush<CR>\|:<C-u>CommandT test/unit<CR>
nnoremap <silent> <Leader>gF :<C-u>CommandTFlush<CR>\|:<C-u>CommandT test/functional<CR>
nnoremap <silent> <Leader>gt :<C-u>CommandTFlush<CR>\|:<C-u>CommandT test<CR>
nnoremap <silent> <Leader>gm :<C-u>CommandTFlush<CR>\|:<C-u>CommandT app/models<CR>
nnoremap <silent> <Leader>gh :<C-u>CommandTFlush<CR>\|:<C-u>CommandT app/helpers<CR>
nnoremap <silent> <Leader>gl :<C-u>CommandTFlush<CR>\|:<C-u>CommandT lib<CR>
nnoremap <silent> <Leader>gp :<C-u>CommandTFlush<CR>\|:<C-u>CommandT public<CR>
nnoremap <silent> <Leader>gs :<C-u>CommandTFlush<CR>\|:<C-u>CommandT public/stylesheets<CR>
nnoremap <silent> <Leader>gS :<C-u>CommandTFlush<CR>\|:<C-u>CommandT spec<CR>
nnoremap <silent> <Leader>gg :<C-u>topleft 100 :split Gemfile<CR>
nnoremap <silent> <Leader>gf :<C-u>CommandT %%/<CR>
nnoremap <silent> <Leader>, :<C-u>CommandTFlush<CR>:<C-u>CommandT<CR>
nnoremap <silent> <Leader> :<C-u>CommandTFlush<CR>:<C-u>CommandTBuffer<CR>
nnoremap <silent> <expr> <CR> &bt == "" ? ":nohlsearch<CR>" : "\<CR>" 

function! Preserve(command)
    let _s=@/
    let l = line(".")
    let c = col(".")
    execute a:command
    let @/=_s
    call cursor(l, c)
endfunction

nmap _$ :call Preserve("%s/\\s\\+$//e")<CR>
nmap _= :call Preserve("normal gg=G")<CR>

function! Titlecase()
    if !executable("toTitleCase")
        echo "Missing toTitleCase excutable."
        return
    endif
    normal gv"xy
    let @x = system('echo "'.@x.'"| toTitleCase | tr -d "\n"')
    let @x = substitute(@x, '^\s*\(.\{-}\)\s*$', '\1', '')
    normal gv
    normal "xp
endfunction
vmap <Leader>t :call Titlecase()<CR>

inoremap <C-O> <C-X><C-O>
inoremap <expr> <C-l> pumvisible() ? "\<C-p>" : "\<C-p>"
nmap <Leader>x <SID>(command-line-enter)<C-u>sp <C-R>=expand("%:h")<CR>/

inoremap <Tab> <c-r>=InsertTabWrapper()<CR>
inoremap <S-Tab> <c-n>
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction

"}}}1

set secure

" vim: foldmethod=marker
